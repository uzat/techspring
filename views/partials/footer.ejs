<!-- views/partials/footer.ejs -->
    <footer class="footer">
        <div class="footer-container">
            <div class="footer-content">
                <div class="footer-section">
                    <h3>TechSpring</h3>
                    <p>AI Innovation & Technology Solutions</p>
                    <p>Mornington Peninsula, Victoria, Australia</p>
                </div>
                <div class="footer-section">
                    <h4>Quick Links</h4>
                    <ul>
                        <li><a href="/">Home</a></li>
                        <li><a href="/about">About</a></li>
                        <li><a href="/blog">Blog</a></li>
                        <li><a href="/contact">Contact</a></li>
                    </ul>
                </div>
                <div class="footer-section">
                    <h4>Connect</h4>
                    <p>Phone: 0481 261 015</p>
                    <p><a href="/acknowledgment">Acknowledgment of Country</a></p>
                </div>
            </div>
            <div class="footer-bottom">
                <p>&copy; 2025 TechSpring Pty Ltd. All rights reserved.</p>
            </div>
        </div>
    </footer>

    <script src="/js/main.js"></script>
    <% if (currentPage === 'home') { %>
        <script src="https://cdn.jsdelivr.net/particles.js/2.0.0/particles.min.js"></script>
        <script src="/js/particles-config.js"></script>
    <% } %>
    <script>
    // Rotating Effects System
    class RotatingEffects {
        constructor() {
            this.effects = [
                'chromeSphere',
                'typedText', 
                'neuralNetwork',
                'aiProcessing'
            ];
            this.currentEffect = this.selectRandomEffect();
            this.init();
        }
        
        selectRandomEffect() {
            // Get a random effect, but avoid the same one as last time
            const lastEffect = localStorage.getItem('lastHeroEffect');
            let availableEffects = this.effects.filter(effect => effect !== lastEffect);
            
            // If all effects have been shown, reset the pool
            if (availableEffects.length === 0) {
                availableEffects = this.effects;
            }
            
            const selectedEffect = availableEffects[Math.floor(Math.random() * availableEffects.length)];
            localStorage.setItem('lastHeroEffect', selectedEffect);
            return selectedEffect;
        }
        
        init() {
            console.log(`Loading hero effect: ${this.currentEffect}`);
            
            // Hide all effect containers
            document.querySelectorAll('.effect-container').forEach(container => {
                container.style.display = 'none';
            });
            
            // Show and initialize the selected effect
            switch(this.currentEffect) {
                case 'chromeSphere':
                    this.initChromeSphere();
                    break;
                case 'typedText':
                    this.initTypedText();
                    break;
                case 'neuralNetwork':
                    this.initNeuralNetwork();
                    break;
                case 'aiProcessing':
                    this.initAIProcessing();
                    break;
            }
        }
        
        initChromeSphere() {
            const container = document.getElementById('chrome-sphere-container');
            container.style.display = 'block';
            
            const canvas = document.getElementById('chrome-sphere');
            const scene = new THREE.Scene();
            const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
            const renderer = new THREE.WebGLRenderer({ canvas: canvas, alpha: true });
            
            renderer.setSize(window.innerWidth, window.innerHeight);
            
            // Create chrome sphere
            const geometry = new THREE.SphereGeometry(2, 32, 32);
            const material = new THREE.MeshBasicMaterial({ 
                color: 0x8b9dc3,
                transparent: true,
                opacity: 0.7,
                wireframe: true
            });
            const sphere = new THREE.Mesh(geometry, material);
            scene.add(sphere);
            
            camera.position.z = 5;
            
            // Animation loop
            function animate() {
                requestAnimationFrame(animate);
                sphere.rotation.x += 0.01;
                sphere.rotation.y += 0.01;
                renderer.render(scene, camera);
            }
            animate();
            
            // Handle resize
            window.addEventListener('resize', () => {
                camera.aspect = window.innerWidth / window.innerHeight;
                camera.updateProjectionMatrix();
                renderer.setSize(window.innerWidth, window.innerHeight);
            });
        }
        
        initTypedText() {
            const container = document.getElementById('typed-container');
            container.style.display = 'block';
            
            const options = {
                strings: [
                    'AI Innovation',
                    'Technology Solutions', 
                    'Future is Now',
                    'TechSpring AI'
                ],
                typeSpeed: 100,
                backSpeed: 50,
                backDelay: 2000,
                loop: true,
                showCursor: true,
                cursorChar: '|'
            };
            
            new Typed('#typed-text', options);
        }
        
        initNeuralNetwork() {
            const container = document.getElementById('neural-network');
            container.style.display = 'block';
            
            const canvas = document.getElementById('neural-canvas');
            const ctx = canvas.getContext('2d');
            
            canvas.width = window.innerWidth;
            canvas.height = window.innerHeight;
            
            const nodes = [];
            const connections = [];
            
            // Create nodes
            for (let i = 0; i < 50; i++) {
                nodes.push({
                    x: Math.random() * canvas.width,
                    y: Math.random() * canvas.height,
                    vx: (Math.random() - 0.5) * 2,
                    vy: (Math.random() - 0.5) * 2,
                    radius: Math.random() * 3 + 1
                });
            }
            
            function animate() {
                ctx.clearRect(0, 0, canvas.width, canvas.height);
                
                // Update nodes
                nodes.forEach(node => {
                    node.x += node.vx;
                    node.y += node.vy;
                    
                    if (node.x < 0 || node.x > canvas.width) node.vx *= -1;
                    if (node.y < 0 || node.y > canvas.height) node.vy *= -1;
                    
                    // Draw node
                    ctx.beginPath();
                    ctx.arc(node.x, node.y, node.radius, 0, Math.PI * 2);
                    ctx.fillStyle = '#00d4aa';
                    ctx.fill();
                });
                
                // Draw connections
                nodes.forEach((node, i) => {
                    nodes.slice(i + 1).forEach(otherNode => {
                        const dist = Math.sqrt(
                            Math.pow(node.x - otherNode.x, 2) + 
                            Math.pow(node.y - otherNode.y, 2)
                        );
                        
                        if (dist < 150) {
                            ctx.beginPath();
                            ctx.moveTo(node.x, node.y);
                            ctx.lineTo(otherNode.x, otherNode.y);
                            ctx.strokeStyle = `rgba(0, 212, 170, ${1 - dist / 150})`;
                            ctx.lineWidth = 1;
                            ctx.stroke();
                        }
                    });
                });
                
                requestAnimationFrame(animate);
            }
            animate();
            
            // Handle resize
            window.addEventListener('resize', () => {
                canvas.width = window.innerWidth;
                canvas.height = window.innerHeight;
            });
        }
        
        initAIProcessing() {
            const container = document.getElementById('ai-processing');
            container.style.display = 'block';
            
            const metrics = [
                { id: 'neural', max: 95 },
                { id: 'data', max: 87 },
                { id: 'model', max: 92 }
            ];
            
            metrics.forEach((metric, index) => {
                setTimeout(() => {
                    this.animateMetric(metric.id, metric.max);
                }, index * 800);
            });
        }
        
        animateMetric(id, targetValue) {
            const fill = document.getElementById(`${id}-fill`);
            const value = document.getElementById(`${id}-value`);
            let current = 0;
            
            const interval = setInterval(() => {
                current += Math.random() * 3;
                if (current >= targetValue) {
                    current = targetValue;
                    clearInterval(interval);
                }
                
                fill.style.width = `${current}%`;
                value.textContent = `${Math.round(current)}%`;
            }, 50);
        }
    }

    // Initialize when DOM is loaded
    document.addEventListener('DOMContentLoaded', () => {
        // Only initialize if we're on a page with the hero section
        if (document.querySelector('.hero-effects-container')) {
            new RotatingEffects();
        }
    });
    </script>
</body>
</html>